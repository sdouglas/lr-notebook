<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title></title>
    <link rel="stylesheet" href="../../../../static/fonts/fa/css/font-awesome.min.css?h=512c7d79">
    <link rel="stylesheet" href="/static/lib/reveal/css/reveal.css">
    <link rel="stylesheet" href="/static/lib/reveal/css/theme/white.css" id="theme">
    <link rel="stylesheet" href="/static/slides.css">
    <style>#lektor-edit-link {display:none;}</style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
      
      <section data-markdown data-separator="^\n\n">
        Starting to rethink this whole slice-paired helix strategy of adding strands two at a time.  It might be too limiting in terms of the types of structures one might wish to build, and also impose arbitrary constraints that make correctly routing scaffold very difficult or impossible.

The original idea was that you&#39;d always start with a complete scaffold loop and you could quickly grow that into a correct structure.  The hope was that having a loop would be instructive to the user in understanding how to construct a scaffold path.  But I think that there may be many cases where there have to be intermediate &#34;incorrect&#34; structures in order to get specific structures.  I also can&#39;t quite think of how to easily handle even simple cases where you add helices 0 and 1, and then remove 0 and 1 and then add back 0 and
3.

I think the best we can do is to have really intuitive and obvious constraints for how to &#34;draw&#34; a scaffold strand.  Basically we&#39;re going to end up with with something that is more similar to the SVG drawing, but the constraints will make it work.

Unpaired ends of scaffold will need drag handles, and dragging them together will pair them, for example.  We can add a suite of more intuitive drawing tools, like a scaffold brush to add more scaffold, and eraser to delete scaffold, etc.  We can allow totally incorrect and disconnected scaffold arrangements and not worry about preventing those.

We&#39;ll have a checking routine which will verify a complete and single scaffold loop (and maybe turn it green to indicate it is legal).  At that point it will be possible to generate staples with default breakpoints and crossovers, and route them similarly.

From Adam:
&gt; In contrast, I think it is hard to start by designing the path in the path
&gt; panel, without already having a default scaffold path generated from the
&gt; lattice. I hadn&#39;t been thinking about it in terms of the user always picturing

I guess I wasn&#39;t clear on this â€“ we would still draw the initial structure using the slice panel.  You would just do it one helix at a time, and on the path panel you would get path &#34;stubs&#34; - basically default horizontal scaffold path lines which are not connected via crossovers.  (see attached)

If you wanted a six-helix bundle, you would draw the six helices in sequential order on the slice panel, and then do the rest of the editing on the path panel.  You could drag the horizontal lines in either direction, and as they crossed segment boundaries, the slice panel would be updated accordingly (since slices are just zero-width planes which indicate where scaffold helices span).

The user could gradually stitch together the scaffold to make a complete loop.

The purpose of the slice panel would thus be to 1) create an initial bit of scaffold in the path panel to be edited further and in doing so 2) define the orientation of helices w.r.t. the hexagonal lattice.

Everything else would be handled in the path panel, and the render3d panel would of course give instant 3D visualization as you build things.

&lt;a href=&#34;1.png&#34;&gt;&lt;img class=&#34;bigthumb&#34; src=&#34;../1.png&#34;&gt;&lt;/a&gt;
      </section>
      
      </div>
    </div>

    <script src="../../../../static/lib/reveal/lib/js/head.min.js?h=8c9495c7"></script>
    <script src="../../../../static/lib/reveal/js/reveal.js?h=19c4134c"></script>
    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        center: false,
        history: true,
        margin: 0.2,
        transition: 'fade', // none/fade/slide/convex/concave/zoom
        transitionSpeed: 'fast', // default/fast/slow

        menu: {
            // Specifies which side of the presentation the menu will
            // be shown. Use 'left' or 'right'.
            side: 'left',

            // Add slide numbers to the titles in the slide list.
            // Use 'true' or format string (same as reveal.js slide numbers)
            numbers: false,

            // Specifies which slide elements will be used for generating
            // the slide titles in the menu. The default selects the first
            // heading element found in the slide, but you can specify any
            // valid css selector and the text from the first matching
            // element will be used.
            // Note: that a section data-menu-title attribute or an element
            // with a menu-title class will take precedence over this option
            titleSelector: 'h1, h2, h3, h4, h5, h6',

            // Hide slides from the menu that do not have a title.
            // Set to 'true' to only list slides with titles.
            hideMissingTitles: false,

            // Add markers to the slide titles to indicate the
            // progress through the presentation
            markers: true,

            // Specify custom panels to be included in the menu, by
            // providing an array of objects with 'title', 'icon'
            // properties, and either a 'src' or 'content' property.
            custom: false,

            // Specifies the themes that will be available in the themes
            // menu panel. Set to 'false' to hide themes panel.
            themes: [
                { name: 'Black', theme: '/static/lib/reveal/css/theme/black.css' },
                { name: 'White', theme: '/static/lib/reveal/css/theme/white.css' },
                { name: 'League', theme: '/static/lib/reveal/css/theme/league.css' },
                { name: 'Sky', theme: '/static/lib/reveal/css/theme/sky.css' },
                { name: 'Solarized', theme: '/static/lib/reveal/css/theme/solarized.css' }
            ],

            // Specifies if the transitions menu panel will be shown.
            transitions: true,

            // Adds a menu button to the slides to open the menu panel.
            // Set to 'false' to hide the button.
            openButton: true,

            // If 'true' allows the slide number in the presentation to
            // open the menu panel. The reveal.js slideNumber option must
            // be displayed for this to take effect
            openSlideNumber: false,

            // If true allows the user to open and navigate the menu using
            // the keyboard. Standard keyboard interaction with reveal
            // will be disabled while the menu is open.
            keyboard: true
        },

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: "../../../../static/lib/reveal/plugin/markdown/marked.js" },
          { src: "../../../../static/lib/reveal/plugin/markdown/markdown.js" },
          { src: "../../../../static/lib/reveal/plugin/menu/menu.js"},
          { src: "../../../../static/lib/reveal/plugin/zoom-js/zoom.js", async: true },
          { src: "../../../../static/lib/reveal/plugin/notes/notes.js", async: true },
          { src: "../../../../static/lib/reveal/plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>

    <a href=".." id="exit-slides-link"><i class="fa fa-close" aria-hidden="true"></i></a>
  </body>
</html>
