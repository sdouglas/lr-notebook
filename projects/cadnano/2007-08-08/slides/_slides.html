<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title></title>
    <link rel="stylesheet" href="../../../../static/fonts/fa/css/font-awesome.min.css?h=512c7d79">
    <link rel="stylesheet" href="/static/lib/reveal/css/reveal.css">
    <link rel="stylesheet" href="/static/lib/reveal/css/theme/white.css" id="theme">
    <link rel="stylesheet" href="/static/slides.css">
    <style>#lektor-edit-link {display:none;}</style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
      
      <section data-markdown data-separator="^\n\n">
        ```actionscript
package
{
    import flash.text.*;
    import flash.events.*;
    import fl.events.SliderEvent;
    import flash.display.*;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    import de.polygonal.ds.*;
    import org.papervision3d.cameras.*;
    import org.papervision3d.events.*;
    import org.papervision3d.materials.*;
    import org.papervision3d.objects.*;
    import org.papervision3d.scenes.*;

    //import org.papervision3d.components.as3.utils.ObjectController;

    public class Main extends Sprite {
        // Sizing
        public static const k_nodeRadius:int  = 10;
        public static const k_nodeHeight:int  = 36; // 0.34*21*radius/2
        public static const k_gridWidth:int   = 26;
        public static const k_gridHeight:int  = 26;
        public static const k_gridSpacing:int = k_nodeRadius * 2;

        // Node
        private var graph:Graph;
        private var grid:Array2;
        private var nodeCanvas:Sprite;
        private var nodeNumbers:LinkedStack;
        private var nodeCount:int = 0;
        // Path

        // 3D render
        private var container:Sprite;
        private var scene:Scene3D;
        private var camera:Camera3D;
        private var rootNode:DisplayObject3D;
        private var cylinderList:Array;
        private var angle:Number = 0;
        public static const camera_x_offset:int  = 150;
        public static const camera_y_offset:int  = 260;
        public static const camera_z_offset:int  = k_nodeHeight/2;

        // Misc
        public static var MyriadProFont:Font = new MyriadPro();

        public function Main() {
            configureListeners();
            stage.quality = &#34;HIGH&#34;;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;

            // 3D stuff
            cylinderList = new Array();

            // Creates scene
            container = new Sprite();
            container.x = 150;
            container.y = 20;
            renderPanel.addChild(container);
            scene = new Scene3D(container);
            rootNode = new DisplayObject3D(&#34;rootNode&#34;);
            scene.addChild(rootNode);

            // Creates cameras
            camera = new Camera3D();
            camera.zoom = 5;
            camera.focus = 200;
            camera.target.z = camera_z_offset;
            addEventListener(Event.ENTER_FRAME, tick);

            // Creates 2D slice grid
            grid = new Array2(k_gridWidth, k_gridHeight);
            graph = new Graph(grid.size);
            Node.RADIUS = k_nodeRadius;
            slicePanel.addChild(nodeCanvas = new Sprite());
            nodeCanvas.x = nodeCanvas.y = k_nodeRadius * 2;
            nodeNumbers = new LinkedStack();

            // Add a mask for slicePanel
            var rect:Shape = new Shape();
            rect.graphics.lineStyle(1, 0x000000);
            rect.graphics.beginFill(0xff0000);
            rect.graphics.drawRect(10, 10, 310, 570);
            rect.graphics.endFill();
            slicePanel.addChild(rect);
            nodeCanvas.mask = rect;

            nodeCanvas.x = -100;
            nodeCanvas.y = -100;
            nodeCanvas.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown)
            nodeCanvas.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

            //create rectangular array of nodes
            var i:int = 0;
            var node:Node;
            for (var y:int = 0; y &lt; grid.height; y++)
            {
                for (var x:int = 0; x &lt; grid.width; x++)
                {
                    node = new Node(i);
                    nodeCanvas.addChild(node);

                    if ((x % 2) ^ (y % 2)) {
                        node.y = y*k_nodeRadius*3*1.05 + k_nodeRadius;
                    } else {
                        node.y = y*k_nodeRadius*3*1.05;
                    }
                    node.x = x*k_nodeRadius*1.7320*1.1

                    var tf:TextField = node.getChildAt(0) as TextField;
                    var tfm:TextFormat = tf.getTextFormat();
                    tfm.size = 14;
                    tf.defaultTextFormat = tfm;

                    graph.addNode(node, i);

                    grid.set(x, y, node);
                    i++;

                    node.addEventListener(MouseEvent.MOUSE_MOVE, onMove, false, 1000);
                    node.addEventListener(MouseEvent.MOUSE_OUT,  onMouseOut, false, 1000);
                    node.addEventListener(MouseEvent.CLICK, onClick, false, 1000);
                }
            }
        }

        private function mouseDown(event:MouseEvent):void {
            nodeCanvas.startDrag();
        }


        private function mouseReleased(event:MouseEvent):void {
            nodeCanvas.stopDrag();
        }


        private function addCylinder(p_x:Number, p_y:Number, p_z:Number):void {
            var cylinderIndex:uint = cylinderList.length;
            var newCylinderMaterial:CompositeMaterial = new CompositeMaterial()
            newCylinderMaterial.addMaterial(new ColorMaterial(0x03a3f0));
            newCylinderMaterial.addMaterial(new WireframeMaterial(0x000000));
            var newCylinder:Cylinder = new Cylinder(newCylinderMaterial, k_nodeRadius+2, k_nodeHeight, 10, 6, 0, null);
            newCylinder.rotationX = 90;
            rootNode.addChild(newCylinder);
            cylinderList[cylinderIndex] = newCylinder;
            newCylinder.x = p_x;
            newCylinder.y = p_y;
            newCylinder.z = p_z;
        }

        private function tick(event:Event):void {
            // A tick of the engine
            camera.x = Math.round(Math.cos(angle)*750 + camera_x_offset);
            camera.z = Math.round(Math.sin(angle)*750 + camera_z_offset);
            angle += 0.03;
            scene.renderCamera(camera);
            basePanel.renderText.text = &#34;cam.x: &#34; + camera.z.toString() +
                                        &#34;  cam.z: &#34; + camera.z.toString();
        }

        private function configureListeners():void {
            basePanel.zoomslider.addEventListener(SliderEvent.CHANGE, sliderChanged);
            basePanel.zoomslider.addEventListener(SliderEvent.THUMB_RELEASE, sliderRelease);
            basePanel.focusslider.addEventListener(SliderEvent.CHANGE, focussliderChanged);
            basePanel.focusslider.addEventListener(SliderEvent.THUMB_RELEASE, foucssliderRelease);
        }

        private function sliderRelease(e:SliderEvent):void {
            camera.zoom = e.target.value;
        }

        private function sliderChanged(e:SliderEvent):void {
            basePanel.zoomsliderLabel.text =  e.target.value;
        }
        private function foucssliderRelease(e:SliderEvent):void {
            camera.y = e.target.value;
        }

        private function focussliderChanged(e:SliderEvent):void {
            basePanel.focussliderLabel.text =  e.target.value;
        }

        private function onClick(e:MouseEvent):void
        {
            // check if target is marked
            if (e.target.marked) {
                // check if pairedNeighbor is marked
                if (e.target.pairedNeighbor.marked) {
                    var a:Array = new Array();
                    // unmark and recover numbers
                    a.push(e.target.unmark());
                    a.push(e.target.pairedNeighbor.unmark());
                    a.sort();
                    nodeNumbers.push(a[0]);
                    nodeNumbers.push(a[1]);

                    // unpair
                    e.target.neighbor.pairedNeighbor = null;
                    e.target.pairedNeighbor = null;
                }
            } else if (!e.target.marked) { // target is unmarked
                if (e.target.neighbor == null) {
                    return; // return if no neighbors
                }
                if (!e.target.neighbor.marked) { // if neighbor is unmarked
                    var parity:int;
                    parity = getNodeParity(e.target);

                    //var s:int = nodeNumbers.size();
                    if (nodeNumbers.peek() == null) {
                        nodeNumbers.push(nodeCount);
                        nodeCount += 1;
                        nodeNumbers.push(nodeCount);
                        nodeCount += 1;
                    }

                    var odd:int = nodeNumbers.pop();
                    var even:int = nodeNumbers.pop();
                    // mark nodes
                    if (parity == 1) {
                        e.target.neighbor.mark(even);
                        e.target.mark(odd);
                    } else {
                        e.target.mark(even);
                        e.target.neighbor.mark(odd);
                    }

                    // pair nodes
                    e.target.pairedNeighbor = e.target.neighbor;
                    e.target.neighbor.pairedNeighbor = e.target;

                    // Path update


                    // 3D render
                    addCylinder(e.target.x, -e.target.y, 0);
                    addCylinder(e.target.neighbor.x, -e.target.neighbor.y, 0);
                    centerXY();
                }
            }
        }

        private function getDist(x1:int,x2:int,y1:int,y2:int):int {
            return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));
        }

        private function centerXY() {
            var n:Node;
            var maxX:int = 0;
            var maxY:int = 0;
            var minX:int = 9999;
            var minY:int = 9999;

            var midX:int = 0;
            var midY:int = 0;

            for (var row:int = 0; row &lt; grid.height; row++)
            {
                for (var col:int = 0; col &lt; grid.width; col++)
                {
                    n = grid.get(col, row);
                    if (!n.marked) continue;
                    if (n.x &gt; maxX) {
                        maxX = n.x;
                    }
                    if (n.x &lt; minX) {
                        minX = n.x;
                    }
                    if (n.y &gt; maxY) {
                        maxY = n.y;
                    }
                    if (n.y &lt; minY) {
                        minY = n.y;
                    }
                }
            }
            midX = (maxX+minX)/2;
            midY = (maxY+minY)/2;
            camera.target.x = midX;
            camera.target.y = -(midY - camera_y_offset);
            camera.y = -(midY-camera_y_offset);
            trace(camera.y)
        }

        private function getNodeParity(n:Object):int
        {
            var rowcol:Array = [];
            var row:int;
            var col:int;
            var parity:int;
            rowcol = grid.rowcolIndex(n); // get (x,y) coords of node
            row = rowcol[0];
            col = rowcol[1];
            parity = (row % 2) ^ (col % 2); // get parity
            return parity;
        }

        private function getRowColParity(row:int, col:int):int
        {
            return (row % 2) ^ (col % 2);
        }

        private function getRowCol(n:Object):Array
        {
            var rowcol:Array = [];
            rowcol = grid.rowcolIndex(n);
            return rowcol
        }

        private function onMouseOut(e:MouseEvent):void
        {
            var neighbors:Array = new Array();
            var rowcol:Array;
            var row:int;
            var col:int;
            var parity:int;
            rowcol = getRowCol(e.target);
            row = rowcol[0];
            col = rowcol[1]
            parity = getRowColParity(row, col);

            // get row + 1 if valid
            if (row &lt; k_gridWidth-1) {
                neighbors.push(grid.get(row+1,col));
            }

            // get row - 1 if valid
            if (row &gt; 0) {
                neighbors.push(grid.get(row-1,col));
            }

            if (parity == 1) { // get col + 1 if valid
                if (col &lt; k_gridHeight-1) {
                    neighbors.push(grid.get(row,col+1));
                }
            } else { // get col+1 if valid
                if (col &gt; 0) {
                    neighbors.push(grid.get(row,col-1));
                }
            }
            var i:int;
            for (i = 0; i &lt; neighbors.length; i++)
            {
                neighbors[i].unhover()
            }
            e.target.unhover();
        }

        private function onMove(e:MouseEvent):void
        {
            var x:int = e.target.x;
            var y:int = e.target.y;
            var row:int;
            var col:int;
            var rowcol:Array = [];
            var parity:int;
            var dist:int;
            var minDist:int = 9999;
            var neighbor:Node;
            var pairedNeighbor:Node;
            var nearestNeighbor:Node;
            var neighbors:Array = new Array();
            var nearestNeighborIndex:int;
            var info:String = &#34;&#34;;

            rowcol = getRowCol(e.target);
            row = rowcol[0];
            col = rowcol[1];
            parity = getRowColParity(row, col);

            info += &#34;mouse:&#34; + e.stageX + &#34;,&#34; + e.stageY + &#34;\n&#34;;
            info += &#34;node &#34; + e.target.graphIndex + &#34;: &#34; + x + &#34;,&#34; + y + &#34;\n&#34;;
            info += &#34;marked: &#34; + e.target.marked + &#34;\n&#34;;
            info += &#34;neighbor: &#34; + e.target.neighbor +  &#34;\n&#34;;
            if (e.target.pairedNeighbor != null) {
                pairedNeighbor = e.target.pairedNeighbor;
                e.target.pairedhover();
                pairedNeighbor.pairedhover();
                basePanel.sliceText.text = info;
                return;
            }

            // get row + 1 if valid
            if (row &lt; k_gridWidth-1) {
                neighbor = grid.get(row+1,col)
                neighbors.push(neighbor);
            }

            // get row - 1 if valid
            if (row &gt; 0) {
                neighbor = grid.get(row-1,col)
                neighbors.push(neighbor);
            }

            if (parity == 1) { // get col + 1 if valid
                if (col &lt; k_gridHeight-1) {
                    neighbor = grid.get(row,col+1)
                    neighbors.push(neighbor);
                }
            } else { // get col+1 if valid
                if (col &gt; 0) {
                    neighbor = grid.get(row,col-1)
                    neighbors.push(neighbor);
                }
            }

            var i:int;
            if (neighbors.length &gt; 0) {
                for (i = 0; i &lt; neighbors.length; i++) {
                    dist = getDist(e.stageX,neighbors[i].x+20,
                                   e.stageY,neighbors[i].y+20);
                    info += &#34;[&#34; + neighbors[i].graphIndex + &#34;:&#34; +
                            dist + &#34;] &#34;;
                    if (neighbors[i].pairedNeighbor != null) {
                        continue;
                    }
                    if (dist &lt; minDist) {
                        minDist = dist;
                        nearestNeighborIndex = i;
                    }
                }

                nearestNeighbor = neighbors[nearestNeighborIndex]
                if (nearestNeighbor == pairedNeighbor) {
                    nearestNeighbor.pairedhover();
                    neighbors.splice(nearestNeighborIndex,1);
                } else if (nearestNeighbor.pairedNeighbor != null) {
                    return;
                } else {
                    nearestNeighbor.hover();
                    e.target.neighbor = nearestNeighbor;
                    e.target.neighbor.neighbor = e.target;
                    neighbors.splice(nearestNeighborIndex,1);
                }

                for (i = 0; i &lt; neighbors.length; i++)
                {
                    neighbors[i].unhover();
                }
            }

            basePanel.sliceText.text = info;
        }
    }
}
```

      </section>
      
      </div>
    </div>

    <script src="../../../../static/lib/reveal/lib/js/head.min.js?h=8c9495c7"></script>
    <script src="../../../../static/lib/reveal/js/reveal.js?h=19c4134c"></script>
    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        center: false,
        history: true,
        margin: 0.2,
        transition: 'fade', // none/fade/slide/convex/concave/zoom
        transitionSpeed: 'fast', // default/fast/slow

        menu: {
            // Specifies which side of the presentation the menu will
            // be shown. Use 'left' or 'right'.
            side: 'left',

            // Add slide numbers to the titles in the slide list.
            // Use 'true' or format string (same as reveal.js slide numbers)
            numbers: false,

            // Specifies which slide elements will be used for generating
            // the slide titles in the menu. The default selects the first
            // heading element found in the slide, but you can specify any
            // valid css selector and the text from the first matching
            // element will be used.
            // Note: that a section data-menu-title attribute or an element
            // with a menu-title class will take precedence over this option
            titleSelector: 'h1, h2, h3, h4, h5, h6',

            // Hide slides from the menu that do not have a title.
            // Set to 'true' to only list slides with titles.
            hideMissingTitles: false,

            // Add markers to the slide titles to indicate the
            // progress through the presentation
            markers: true,

            // Specify custom panels to be included in the menu, by
            // providing an array of objects with 'title', 'icon'
            // properties, and either a 'src' or 'content' property.
            custom: false,

            // Specifies the themes that will be available in the themes
            // menu panel. Set to 'false' to hide themes panel.
            themes: [
                { name: 'Black', theme: '/static/lib/reveal/css/theme/black.css' },
                { name: 'White', theme: '/static/lib/reveal/css/theme/white.css' },
                { name: 'League', theme: '/static/lib/reveal/css/theme/league.css' },
                { name: 'Sky', theme: '/static/lib/reveal/css/theme/sky.css' },
                { name: 'Solarized', theme: '/static/lib/reveal/css/theme/solarized.css' }
            ],

            // Specifies if the transitions menu panel will be shown.
            transitions: true,

            // Adds a menu button to the slides to open the menu panel.
            // Set to 'false' to hide the button.
            openButton: true,

            // If 'true' allows the slide number in the presentation to
            // open the menu panel. The reveal.js slideNumber option must
            // be displayed for this to take effect
            openSlideNumber: false,

            // If true allows the user to open and navigate the menu using
            // the keyboard. Standard keyboard interaction with reveal
            // will be disabled while the menu is open.
            keyboard: true
        },

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: "../../../../static/lib/reveal/plugin/markdown/marked.js" },
          { src: "../../../../static/lib/reveal/plugin/markdown/markdown.js" },
          { src: "../../../../static/lib/reveal/plugin/menu/menu.js"},
          { src: "../../../../static/lib/reveal/plugin/zoom-js/zoom.js", async: true },
          { src: "../../../../static/lib/reveal/plugin/notes/notes.js", async: true },
          { src: "../../../../static/lib/reveal/plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>

    <a href=".." id="exit-slides-link"><i class="fa fa-close" aria-hidden="true"></i></a>
  </body>
</html>
